<!DOCTYPE html>
<html>
<head>
  <link rel='stylesheet' href='styleoverlay.css'>
</head>
<body>
  <!-- create the two divs of the overlay: file feed and border -->
  <div id='file-feed'></div>
  <div id='border' style='display:none;'></div>

  <script>
    // declare variables
    const fileFeed = document.getElementById('file-feed');
    const blockTimestamps = [];
    const MAX_DISPLAYED_BLOCKS = 10;
    const BLOCK_LIFETIME_MS = 60000;
    let resizing = false;
    let showingBorder = false;

    // declare the scrollOverlay function
    function scrollOverlay(direction) {
      if (direction === 'up') {
        fileFeed.scrollTop = Math.max(0, fileFeed.scrollTop - 80);
      } else if (direction === 'down') {
        fileFeed.scrollTop = Math.min(fileFeed.scrollHeight, fileFeed.scrollTop + 80);
      }
    }

    // Set up event listeners for resizing and border visibility
    window.electronAPI.onToggleResizeBorder(isResize => {
      const border = document.getElementById('border');
      if (border && !showingBorder) {
        border.style.display = isResize ? 'block' : 'none';
      }
    });

    // set up event listener for showing the border
    window.electronAPI.onMakeShowBorder(showBorder => {
      const border = document.getElementById('border');
      if (border) {
        border.style.display = showBorder ? 'block' : 'none';
      }
      showingBorder = showBorder; 
    });

    // set up event listener for file content updates that tags and appends new content to the file feed and removes old content if the maximum number of displayed blocks is reached
    // recall: this function is called when the main process sends the formatted log contents to the renderer process
    window.electronAPI.onFileContentUpdate((dataArray) => {
      if (!Array.isArray(dataArray) || dataArray.length === 0) return;
      const entry = dataArray[dataArray.length - 1];
      if (!entry) return;
      const existingBlock = Array.from(fileFeed.children).find(child => child.dataset.id === entry.id);
      if (existingBlock) return;
      while (blockTimestamps.length >= MAX_DISPLAYED_BLOCKS) {
        const { el } = blockTimestamps.shift();
        const prev = el.previousSibling;
        if (prev && prev.tagName === 'BR') fileFeed.removeChild(prev); 
        if (el.parentNode === fileFeed) fileFeed.removeChild(el); 
      }
      if (fileFeed.children.length > 0) {
        fileFeed.appendChild(document.createElement('br'));
      }
      const plcDiv = document.createElement('div');
      plcDiv.classList.add('file-content-block');
      plcDiv.textContent = entry.content;
      plcDiv.dataset.id = entry.id; 
      fileFeed.appendChild(plcDiv);
      blockTimestamps.push({ id: entry.id, el: plcDiv, time: Date.now() });
      fileFeed.scrollTop = fileFeed.scrollHeight;
    });

    // set up a timer to remove old entries
    setInterval(() => {
      const now = Date.now();
      while (blockTimestamps.length > 0 && now - blockTimestamps[0].time > BLOCK_LIFETIME_MS) {
        const { el } = blockTimestamps.shift();
        const prev = el.previousSibling;
        if (prev && prev.tagName === 'BR') fileFeed.removeChild(prev);
        if (el.parentNode === fileFeed) fileFeed.removeChild(el);
      }
    }, 1000); 
    if (window.electronAPI && window.electronAPI.onScrollOverlay) {
      window.electronAPI.onScrollOverlay(scrollOverlay);
    }
  </script>
</body>
</html>